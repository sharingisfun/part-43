{"title":"Joy of Clojure - Full Text","uid":6228641,"size":710077,"categoryP":"other","categoryS":"e_books","magnet":"?xt=urn:btih:fd2bf18c824281585f659e971cc22849b5df4962&amp;dn=Joy+of+Clojure+-+Full+Text&amp;tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&amp;tr=udp%3A%2F%2Fopen.demonii.com%3A1337&amp;tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&amp;tr=udp%3A%2F%2Fexodus.desync.com%3A6969","seeders":1,"leechers":0,"uploader":"Marcy93","files":2,"time":1299614843,"description":"This is the full pre-release text of the book \\\\\\&quot;The Joy of Clojure\\\\\\&quot; by Michael Fogus and Chris Houser. The text has been extracted to an HTML file with some loss of formatting, but the book is still very readable.\n\n\n\nTABLE OF CONTENTS\n\n         1. Foreword (to be announced)\n         2. Acknowledgments\n         3. Introduction\n         4. Notational Conventions\n         5. Getting Clojure\n         6. Road Map\n      FOUNDATIONS\n         1. Clojure Philosophy\n               1. The Clojure Way\n               2. Why a(nother) Lisp?\n               3. Functional Programming\n               4. Why Clojure is Not Especially Object-oriented\n               5. Summary\n         2. Drinking From the Clojure Firehose\n               1. Scalars\n               2. Putting Things Together: Collections\n               3. Making Things Happen: Functions\n               4. Vars\n               5. Locals, Loops, and Blocks\n               6. Preventing Things from Happening: Quoting\n               7. Leveraging Java via Interop\n               8. Exceptional Circumstances\n               9. Namespaces\n              10. Summary\n         3. Dipping Our Toes Into the Pool\n               1. Truthiness\n               2. nil Pun With Care\n               3. Using Destructuring\n               4. Using the REPL to Experiment\n               5. Summary\n      DATA TYPES\n         3. On Scalars\n               1. Understanding Precision\n               2. Try To Be Rational\n               3. When To Use Keywords\n               4. Symbolic Resolution\n               5. Regular Expressions - The \\\\\\&quot;Second Problem\\\\\\&quot;\n               6. Summary\n         4. Composite Data Types\n               1. Persistence, Sequences, and Complexity\n               2. Vectors: Creating and Using Them in All Their Varieties\n               3. Lists: Clojure\\\\\\'s Code Form Data Structure\n               4. How to Use Persistent Queues\n               5. Persistent Sets\n               6. Thinking in Maps\n               7. Putting It All Together: Finding the Position of Items in a Sequence\n               8. Summary\n      FUNCTIONAL PROGRAMMING\n         5. Being Lazy and Set in Your Ways\n               1. On Immutability\n               2. Designing a Persistent Toy\n               3. On Laziness\n               4. Putting It All Together: A Lazy Quicksort\n               5. Summary\n         6. Functional Programming\n               1. Functions in All Their Forms\n               2. Closures\n               3. Thinking Recursively\n               4. Putting It All Together: A* Pathfinding\n               5. Summary\n      LARGE-SCALE DESIGN\n         7. Macros\n               1. Data is Code is Data\n               2. Defining Control Structures\n               3. Macros Combining Forms\n               4. Using Macros When Changing Forms\n               5. Using Macros to Control Symbolic Resolution Time\n               6. Using Macros to Manage Resources\n               7. Putting It All Together: Macros Returning Functions\n               8. Summary\n         8. Combining Data and Code\n               1. Namespaces\n               2. Exploring Multimethods with the Universal Design Pattern\n               3. Types, Protocols, and Records\n               4. Putting it All Together: A Fluent Builder for Chess Moves\n         9. Java.next\n               1. Generating Objects On the Fly with proxy\n               2. Clojure gen-class and GUI Programming\n               3. Clojure\\\\\\'s Relationship to Java Arrays\n               4. All Clojure Functions Implement...\n               5. Using Clojure Data Structures In Java APIs\n               6. definterface\n               7. Be Wary of Exceptions\n               8. Summary\n        10. Mutation\n               1. Software Transactional Memory with Multiversion Concurrency Control and Snapshot Isolation\n               2. When To Use Refs\n               3. When To Use Agents\n               4. When To Use Atoms\n               5. When To Use Locks\n               6. When To Use Futures\n               7. When To Use Promise and Deliver\n               8. Parallelism\n               9. Vars and Dynamic Binding\n              10. Summary\n      TANGENTIAL CONSIDERATIONS\n        11. Performance\n               1. Type Hints\n               2. Transients\n               3. Chunked Sequences\n               4. Memoization\n               5. Understanding Coersion\n               6. Summary\n        12. Clojure Changes the Way You Think\n               1. DSLs\n               2. Testing\n               3. A Lack of Design Patterns\n               4. Error Handling and Debugging\n               5. Fare Thee Well\n         1. Appendix A: Clojure Style\n         2. Appendix B: Annotated Bibliography\n","torrent":{"xt":"urn:btih:fd2bf18c824281585f659e971cc22849b5df4962","amp;dn":"Joy+of+Clojure+-+Full+Text","amp;tr":["udp%3A%2F%2Ftracker.openbittorrent.com%3A80","udp%3A%2F%2Fopen.demonii.com%3A1337","udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969","udp%3A%2F%2Fexodus.desync.com%3A6969"],"infoHash":"fd2bf18c824281585f659e971cc22849b5df4962","infoHashBuffer":{"type":"Buffer","data":[253,43,241,140,130,66,129,88,95,101,158,151,28,194,40,73,181,223,73,98]},"announce":[],"urlList":[]}}